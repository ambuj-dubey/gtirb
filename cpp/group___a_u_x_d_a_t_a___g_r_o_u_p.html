<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>GTIRB: AuxData</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">GTIRB
   &#160;<span id="projectnumber">v1.0.0</span>
   </div>
   <div id="projectbrief">GrammaTech Intermediate Representation for Binaries: C++ API</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#files">Files</a> &#124;
<a href="#nested-classes">Classes</a>  </div>
  <div class="headertitle">
<div class="title">AuxData</div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classgtirb_1_1_aux_data.html">AuxData</a> objects can be attached to the <a class="el" href="classgtirb_1_1_i_r.html">IR</a> or individual Modules to store additional client-specific data in a portable way.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="files"></a>
Files</h2></td></tr>
<tr class="memitem:_aux_data_8hpp"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_aux_data_8hpp.html">AuxData.hpp</a></td></tr>
<tr class="memdesc:_aux_data_8hpp"><td class="mdescLeft">&#160;</td><td class="mdescRight">Types and operations for auxiliar data. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtirb_1_1_aux_data.html">gtirb::AuxData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A generic object for storing additional client-specific data.  <a href="classgtirb_1_1_aux_data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgtirb_1_1auxdata__traits.html">gtirb::auxdata_traits&lt; T, Enable &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides type information and serialization functions for types which can be stored in <a class="el" href="classgtirb_1_1_aux_data.html">AuxData</a>.  <a href="structgtirb_1_1auxdata__traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgtirb_1_1auxdata__traits_3_01_addr_01_4.html">gtirb::auxdata_traits&lt; Addr &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgtirb_1_1auxdata__traits_3_01_offset_01_4.html">gtirb::auxdata_traits&lt; Offset &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgtirb_1_1auxdata__traits_3_01std_1_1byte_01_4.html">gtirb::auxdata_traits&lt; std::byte &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgtirb_1_1auxdata__traits_3_01std_1_1set_3_01_args_8_8_8_01_4_01_4.html">gtirb::auxdata_traits&lt; std::set&lt; Args... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgtirb_1_1auxdata__traits_3_01std_1_1string_01_4.html">gtirb::auxdata_traits&lt; std::string &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgtirb_1_1auxdata__traits_3_01_t_00_01typename_01std_1_1enable__if__t_3_01is__mapping_3_01_t_01_4_1_1value_01_4_01_4.html">gtirb::auxdata_traits&lt; T, typename std::enable_if_t&lt; is_mapping&lt; T &gt;::value &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgtirb_1_1auxdata__traits_3_01_t_00_01typename_01std_1_1enable__if__t_3_01is__sequence_3_01_t_01_4_1_1value_01_4_01_4.html">gtirb::auxdata_traits&lt; T, typename std::enable_if_t&lt; is_sequence&lt; T &gt;::value &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgtirb_1_1auxdata__traits_3_01_t_00_01typename_01std_1_1enable__if__t_3_01std_1_1is__integr0e17a2fe23707f85d9b7ee37006d43d0.html">gtirb::auxdata_traits&lt; T, typename std::enable_if_t&lt; std::is_integral&lt; T &gt;::value &amp;&amp;std::is_signed&lt; T &gt;::value &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgtirb_1_1auxdata__traits_3_01_t_00_01typename_01std_1_1enable__if__t_3_01std_1_1is__integr6c91c3697cd76f9e2f07ffcf93881722.html">gtirb::auxdata_traits&lt; T, typename std::enable_if_t&lt; std::is_integral&lt; T &gt;::value &amp;&amp;std::is_unsigned&lt; T &gt;::value &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgtirb_1_1auxdata__traits_3_01_u_u_i_d_01_4.html">gtirb::auxdata_traits&lt; UUID &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgtirb_1_1default__serialization.html">gtirb::default_serialization&lt; T, Enable &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgtirb_1_1default__serialization_3_01_t_00_01typename_01std_1_1enable__if__t_3_01is__endian4f5c4fb55a0c747862fc298dd807a706.html">gtirb::default_serialization&lt; T, typename std::enable_if_t&lt; is_endian_type&lt; T &gt;::value &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgtirb_1_1is__mapping.html">gtirb::is_mapping&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait class that identifies whether T is a mapping container type.  <a href="structgtirb_1_1is__mapping.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgtirb_1_1is__sequence.html">gtirb::is_sequence&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait class that identifies whether T is a sequential container type.  <a href="structgtirb_1_1is__sequence.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p><a class="el" href="classgtirb_1_1_aux_data.html">AuxData</a> objects can be attached to the <a class="el" href="classgtirb_1_1_i_r.html">IR</a> or individual Modules to store additional client-specific data in a portable way. </p>
<p><a class="el" href="classgtirb_1_1_aux_data.html" title="A generic object for storing additional client-specific data.">AuxData</a> can store the following types:</p><ul>
<li>all integral types</li>
<li><a class="el" href="classgtirb_1_1_addr.html" title="A special class to store an Effective Address.">Addr</a></li>
<li><a class="el" href="structgtirb_1_1_offset.html" title="Describes a location inside a block or data object.">Offset</a></li>
<li><a class="el" href="namespacegtirb.html#a70b3d23477329aeb2a0d320d0c50e1e5">UUID</a></li>
<li>sequential containers</li>
<li>mapping containers</li>
<li>std::tuple</li>
</ul>
<h3><a class="anchor" id="autotoc_md0"></a>
Supporting Additional Types</h3>
<p>Support for additional containers can be added by specializing <a class="el" href="structgtirb_1_1is__sequence.html">is_sequence</a> or <a class="el" href="structgtirb_1_1is__mapping.html">is_mapping</a>. Once serialized, the data does not depend on any specific container type, and its contents can be deserialized into different containers of the same kind (e.g. <code>std::list</code> to <code>std::vector</code>).</p>
<p>Support for other types can be added by specializing <a class="el" href="structgtirb_1_1auxdata__traits.html">auxdata_traits</a> to provide serialization functions. However, <a class="el" href="classgtirb_1_1_aux_data.html">AuxData</a> containing these types will not be accessible to other clients which are not compiled with support for those types. It is preferable to store data using the basic types whenever possible, in order to maximize interoperability.</p>
<h3><a class="anchor" id="autotoc_md1"></a>
'Sanctioned' AuxData Tables</h3>
<p>We specify a small number of standard <a class="el" href="classgtirb_1_1_aux_data.html" title="A generic object for storing additional client-specific data.">AuxData</a> table schemate to support interoperability. For details, see md_AuxData.</p>
<h3><a class="anchor" id="autotoc_md2"></a>
Serialization Format</h3>
<p><a class="el" href="classgtirb_1_1_aux_data.html" title="A generic object for storing additional client-specific data.">AuxData</a> is serialized by packing the contents into a byte array, which is stored in a protobuf message along with a string which identifies the type in a portable fashion.</p>
<p>Fixed-size types such as integers, <a class="el" href="classgtirb_1_1_addr.html" title="A special class to store an Effective Address.">Addr</a>, etc are packed by swapping their bytes to little-endian order and writing them directly to the byte array. Containers first write out the number of elements (as a uint64_t), then write each element one after another. Tuples are similar but omit the size, since it can be inferred from the type. </p>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
